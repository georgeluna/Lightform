If I were designing an API, I think one of the first things I would make sure I have nailed down properly are authentication and authorization. One way I've handled authentication in the past for specific routes is by using encrypted access tokens that would be given to the client once they have confirmed their identity. The server will then expect a x-access-token header containing this token on each request made to it, which will be decrypted and verified before each request is performed. If the token is invalid and/or expired, then any request sent to authenticated routes shall be rejected with a 401 Unauthorized error. If the access token IS valid, but the user does not have the authorization to access a particular route/piece of data (via access control like the ones I've described in the database section), then I'll go ahead and throw a 403 Forbidden error.

For the purposes of this assignment, I'll go ahead and forego authentication/authorization considerations and assume the client I am using already sends the typical headers with each request it makes (Host, User-Agent, Accept, etc).

API
===

I will be implementing the following four web services:

	- AddDevice: Adding a device
	- GetAllDevices: Listing all devices for an organization
	- AssignDevice: Adding (assigning) a device to a user
	- UnassignDevice: Removing (unassigning) a device from a user
	
Now when it comes to the format of the data that is exchanged between the server and client, I usually prefer to use JSON since it can be readily parsed within Javascript, especially when using a runtime environment like Node.js or a single-page application framework like Angular. For information sent via parameters or the body, the server will check to ensure that all of the parameters exist before processing the request (including any relevant SQL queries). If not, then we will throw something like a 400 Bad Request error and maybe some data that explains which expected inputs were missing from the request.

A response body for this API may look something like this:

	{
		"success": true,
		"code": "ERR_41",
		"message": "Device LF1DXC21222 has been successfully added to the organization.",
		"data" {}
	}

	"success": boolean that indicates whether or not the request was successful if it can't be inferred from the response code for some reason.
	"code": error code that may accompany a failure.
	"message": optional message that may describe what has happened or the nature of an error.
	"data": payload of a request, may hold debug data if the request has failed.

ADDDEVICE
---
The AddDevice service will allow a user to add a new device to an existing organization.

Method:	POST
Route:	"/devices"
Headers:
	"Content-Type": "application/json"
Body:
	"hostname": the hostname of the device as it will appear within the organization's network
	"model": the model number of the device
	"serial": the serial number of the device
	"orgid": the unique ID that corresponds to the organization this will be added to
	
The following is how the body for the request would look like as a JSON object:

	{
		"hostname": "ORGDEV1",
		"model": "LF1",
		"serial": "LF1DXC16V3A",
		"orgid": "1"
	}

Presumably, the client already knows which organization the user pertains to either from the payload of an an encrypted access token or from the results of a service that displays all of the organizations within the system.

Once we have verified that we have all of the data we need from the body, we can go ahead and insert the new device into the system with this SQL query:

	INSERT INTO devices (hostname, org_id, model, serial) VALUES ?

Where ? is the list of values from the JSON object.

We may take some extra steps to not only verify that the user pertains to the organization they sent in the body, but also if they have permission within that organization to even add new devices. We might also catch whether or not we are trying to add a duplicate device to the organization (access level). In any of these cases, we would throw some sort of 4xx error to indicate that the request has failed, as well as returning any relevant debug data to help explain why the request failed.

If all goes well, then we shall receive a response with the following data:

	{
		"success": true,
		"message": "Device LF1DXC16V3A has been successfully added to the organization.",
		"data": {
			"deviceid": 1
		}
	}

Headers:
	"Content-Type": "application/json"

Body:
	"deviceid": This will be the new device ID that is generated by the server once the new device is inserted into the database.
	
With the new device ID, the client is free to do what they please with it.

GETALLDEVICES
---
The GetAllDevices service will fetch all of the devices for an organization.

Method:	GET
Route:	"/device?orgid=value1&page=value2"
	
Params:
	"orgid": The ID that corresponds to the organization we are querying against.
	"page": The page number we are currently on (optional)
	
With this information, we can perform the following query:

	SELECT id, hostname, model, serial FROM devices where org_id = ?
	
Where ? is the orgid parsed from the query params.

If a page was provided as one of the params, we could append the following to the SQL statement:

	LIMIT ?,5
	
Where ? is the row offset that is calculated based on the page number that is set and the number of items we want to display per page.

We can return all of the devices as a JSON array, where each object in the array follows this format:

	{
		"success": true,
		"data": [
			{
				"id": "17",
				"hostname": "ORGDEV1",
				"model": "LF1",
				"serial": "LF1DXC16V3A"
			},
			{
				"id": "18",
				"hostname": "ORGDEV2",
				"model": "LF1",
				"serial": "LF1DXC22D4C"
			}
		]
	}

If no organization exists with that orgid, then we can just throw a simple 404 error to the user.

ASSIGNDEVICE
---
The AssignDevice service enables a user's access to a particular device.

Method: POST
Route: "/device/:deviceid/assign"
Headers:
	"Content-Type": "application/json"
Params:
	"deviceid": the unique ID of the device (not the serial number) that will be given access to
Body:
	"userid": the unique ID of the user we will be enabling access for this device to.
	"orgid": the unique ID of the organization that corresponds to both the user and the device
	"access": the access level that this user will have with this device
	
The following is how the url would look like for assigning a user to device with id of 17:

	POST /device/17/assign HTTP/1.1
	
The following is how the body for the request would look like as a JSON object:

	{
		"userid": "1",
		"orgid": "1",
		"access": "0"
	}
	
Once we know we've got all the data we need, we can run the following SQL query:

	INSERT INTO assignments (device_id, user_id, org_id, access) VALUES ?

Where ? is the list of values from both the params and the JSON object body.
	
If successful, we can return an appropriate message in the "message" field for our response:

	{
		"success": true,
		"message": "Device with ID of 17 has been successfully assigned to User with ID of 1"
	}

UNASSIGNDEVICE
---
The AssignDevice service revokes a user's access to a particular device.

Method: POST
Route: "/device/:deviceid/unassign"
Headers:
	"Content-Type": "application/json"
Params:
	"deviceid": the unique ID of the device (not the serial number) that will be given access to
Body:
	"userid": the unique ID of the user we will be enabling access for this device to.
	
The following is how the url would look like for assigning a user to device with id of 17:

	POST /device/17/unassign HTTP/1.1
	
The following is how the body for the request would look like as a JSON object:

	{
		"userid": "1"
	}

Once we know we've got all the data we need, we can run the following SQL query:

	DELETE FROM assignments WHERE device_id = ? AND user_id = ?

If successful, we can return an appropriate message in the "message" field for our response:

	{
		"success": true,
		"message": "User with ID 1 has been successfully unassigned from device with ID 17"
	}
	
QUESTIONS
===

In my previous position, I realized the importance of having a stable API by assessing all of the changes that need to be done whenever it is updated, as well as ensuring backwards compatibility when necessary. As such, we try to design our APIs/web services with the future in mind as requirements and feature sets change, which may require anticipating which inputs for a particular web service are not likely to change as well as easily accomodating new inputs.

VERSIONING
---
The easiest thing to do might be developing some sort of versioning scheme that indicates the API version that a particular client is still using. This can either be done via a query parameter, a custom header on each request, or as part of the body data. This way we can let the application handle previous versions of an API as we please, or if future versions deprecated a particular web service that a route points to, reject the request.

Though it could also be even easier to reject requests intended for old API versions altogether and force the client to update their application to the latest version.

GROWING DATA
---
I would anticipate that, over time, web services will be returning more data as the API changes to accomodate for new data fields and as the system itself is populated with even more data.

For the latter, the first thing that comes to mind is pagination. There's no reason why we have to return ALL of the data at once. Similar to my GetAllDevices web service, we can provide a query parameter for the current page, as well as another parameter for the number of rows to return. This way, clients won't be overwhelmed with large amounts of data all at once and can comfortably navigate through it page-by-page.

Additionally, we can leave the burden to the client of deciding which data they want to display. For example, rather than returning all the columns that we THINK the client will want, we can let them send query parameters that indicate the exact data they expect to be returned by the web service. This could be useful when displaying tabulated data, if the client is to have the ability to hide particular columns to prevent the screen from being too cluttered.

STACK OF CHOICE
---
In general I think consistency is important when developing a system, and using a single technology will definitely be good for code maintainability. However, I would not want to limit myself to a particular stack when developing web services, because I know that different sets of technologies have different benefits that can come together as a very effective solution.

I admit, I really like the idea of building a backend system entirely in Node.js since it is relatively easier to pick up Javascript than another language like Java. However, I would definitely choose Java if I expect to provide services that are more than just simply proceesing requests to a database. If I expect to provide services that might involve something that is more computationally intensive (image/video processing for example), then I would imagine that I could create an API that runs through a Java servlet that gives me access to all of the libraries that are readily accessible from such a battle-tested backend language. Even better, the Java language provides easier facilites on developing multithreaded applications vs. Node.js's workers, so Java applications could potentially scale vertically better than Node.js ones.

